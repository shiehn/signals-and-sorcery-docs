---
sidebar: auto
---

![elixirs](/sas_elixir.png)

# Elixirs

## What are they?
Elixir AIs are python scripts that are registered with the Signals & Sorcery discovery server.  They are triggered remotely by Crucible plugins.  They can be run locally, on a remote server, or as Jupyter Notebooks.  They can be used to execute arbitrary code, or to wrap existing libraries.

## How do I use them?

1. Install a [Crucible plugin](/crucible-plugins/).
2. Generate & copy a "token" from a Crucible Plugin interface (top bar).
3. Choose a colab below and follow the link. 
4. Open the colab in Google Colab by clicking the "Open in Colab" button.
5. Paste the "token" into Colab.  Find the token variable (called something similar to `dawnet_token`).  Set the value.
6. At this point the Plugin and the Colab server should have `found` each other via the underlying web-socket server.
7. Fill in values & files in the colab form.  Click "Run" in the colab form.
 
## Google Colabs

Find premade Elixirs here: [Google CoLabs](/vault/#google-colabs)

# Elixir Client

The Elixir client is a Python package that enables you to write python functions, package the functions and expose them to Crucible plugins.  It is a simple wrapper around the Signals & Sorcery API.


## How do I make my own?
Creating your own Elixir involves a few steps.  
- Copy and modify the [Elixir Template](https://github.com/shiehn/elixirs/blob/main/elixir_template.ipynb).  You  will see a commented section indicating where to write your custom code.  You can write any Python3 code you wish.  
- Test the `.ipynb` file in a Jupyter Notebook
- Use the Runes-CLI to covert the `.ipynb` file into an Elixir AI. 

```python
import elixir_client.core as elixir 
from elixir_client import DAWNetFilePath, ui_param

# The token is generated by the DAWNet plugin.  
# It is used by the discovery server to associate the remote with the plugin.
TOKEN="0715c132-0b31-406e-b562-9206c479a48a" 

# The registered method can be named anything. Note: the method must be `async`.  
# All parameters must be type hinted.  
# 4 parameter types are supported: int, float, str, DAWNetFilePath
# DAWNetFilePath is a special type. When the file is sent to the remote, it is intercepted by the system and 
# transported to a temp dir on the remote.  In this case the variable `b` is local path to the file.

# The `ui_param` is an optional decorator. It is used to define how the parameter input UI will be rendered in the plugin.  
# If the decorator is not used, the parameter will be rendered as a text input field. 
@ui_param('a', 'DAWNetNumberSlider', min=0, max=10, step=1, default=5)
@ui_param('c', 'DAWNetMultiChoice', options=['cherries', 'oranges', 'grapes'], default='grapes')
async def arbitrary_method(a: int, b: DAWNetFilePath, c: str):
    try: 
        # -----------------------------------------
        # This is where you can write custom code to operate on the input params.
        # ex param `a` could be the number of variations created from param `b` using something like MusicLM
        # -----------------------------------------
        
        # This is how you send results back to the plugin, when processing is complete.
        await elixir.results().add_file(b) 
        # This message is displayed in the plugin.
        await elixir.results().add_message("This is a message XYZ") 

        return True
    except Exception as e: 
        #explicitly send an error message back to the plugin
        await elixir.results().add_error(f"Method encountered an error: {e}")
        return False


# The token generated by the plugin. 
elixir.set_token(token=TOKEN)
# The name of the remote.  This is displayed in the plugin.
elixir.set_name("My Remote Code")
# The description of the remote.  This is displayed in the plugin.
elixir.set_description("This is not a real description.")
# Register the method with the discovery server.
elixir.register_method(arbitrary_method)

# When a file is sent to the remote as a DAWNetFilePath, it will become available at this sample rate. 
elixir.set_input_target_sample_rate(44100) #supported values [22050, 32000, 44100, 48000]
# When a file is sent to the remote as a DAWNetFilePath, it will become available at this bit rate. 
elixir.set_input_target_bit_depth(16) #supported values [16, 24, 32]
# When a file is sent to the remote as a DAWNetFilePath, it will become available with this number of channels.
elixir.set_input_target_channels(2) #supported values [1, 2] mono/stereo respectively
# When a file is sent to the remote as a DAWNetFilePath, it will become available in this format.
elixir.set_input_target_format('wav') #supported values ["wav", "mp3", "aif", "flac"]

# When results are sent back to the plugin, they will be sent at this sample rate.
elixir.set_output_target_sample_rate(44100)
# When results are sent back to the plugin, they will be sent at this bit rate.
elixir.set_output_target_bit_depth(16)
# When results are sent back to the plugin, they will be sent with this number of channels.
elixir.set_output_target_channels(2)
# When results are sent back to the plugin, they will be sent in this format.
elixir.set_output_target_format('wav')

# This should be the last line of the script.  It connects to the discovery server and waits for a remote trigger.
elixir.connect_to_server()
```

::: danger
NOTE: The system does not guarantee any security.  Do not expose sensitive data in your remotes.
:::